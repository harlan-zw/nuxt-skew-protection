import type { CookieSerializeOptions } from 'cookie-es'
import type { NuxtSkewProtectionRuntimeConfig } from '~/src/runtime/types'
import { existsSync } from 'node:fs'
import {
  addComponent,
  addImports,
  addPlugin,
  addServerHandler,
  addTypeTemplate,
  createResolver,
  defineNuxtModule,
} from '@nuxt/kit'
import { isStaticPreset, resolveNitroPreset } from './kit'
import { logger } from './logger'
import { resolveBuildTimeDriver } from './unstorage/utils'
import { createAssetManager } from './utils/version-manager'

export interface ModuleOptions {
  /**
   * Storage configuration for versioned assets
   */
  storage?: (Record<string, any> & {
    driver: string
  })
  /**
   * How long to retain old versions (in days)
   * @default 30
   */
  retentionDays?: number
  /**
   * Maximum number of versions to retain
   * @default 10
   */
  maxNumberOfVersions?: number
  /**
   * Strategy for checking for version updates
   * - 'polling': Nuxt's native polling of builds/latest.json (default)
   * - 'sse': Use Server-Sent Events for real-time updates (requires sse: true)
   * - 'ws': Use WebSocket via Cloudflare Durable Objects (requires durableObjects: true)
   * @default Static: 'polling', Node: 'sse', Cloudflare: 'ws'
   */
  checkForUpdateStrategy: 'polling' | 'sse' | 'ws'
  /**
   * Cookie configuration for storing deployment version
   */
  cookie?: Omit<CookieSerializeOptions, 'encode'> & {
    /**
     * Cookie name for storing deployment version
     * @default '__nkpv'
     */
    name?: string
  }
  /**
   * Bundle previous deployment chunks to support users on old versions
   * When enabled, old build assets are stored and served to users who haven't refreshed
   * @default true
   * @note Automatically disabled when using CDN URL
   */
  bundlePreviousDeploymentChunks?: boolean
  /**
   * Enable or disable the module
   * @default true
   */
  enabled: boolean
  /**
   * Enable debug logging
   * @default false
   */
  debug?: boolean
}

export interface ModulePublicRuntimeConfig {
  skewProtection: NuxtSkewProtectionRuntimeConfig
}

export default defineNuxtModule<ModuleOptions>({
  meta: {
    name: 'nuxt-skew-protection',
    compatibility: {
      nuxt: '>=4.0.0',
    },
    configKey: 'skewProtection',
  },
  defaults: {
    retentionDays: 30,
    maxNumberOfVersions: 10,
    bundlePreviousDeploymentChunks: true,
    cookie: {
      name: '__nkpv',
      path: '/',
      sameSite: 'strict' as const,
      maxAge: 60 * 60 * 24 * 60, // 60 days
    },
    storage: {
      driver: 'fs',
      base: 'node_modules/.cache/nuxt/skew-protection',
    },
    debug: false,
  },
  async setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)
    logger.level = (options.debug || nuxt.options.debug) ? 4 : 3
    if (options.enabled === false) {
      logger.debug('The module is disabled, skipping setup.')
      return
    }

    // Add runtime config for client access to module options
    nuxt.options.runtimeConfig.public = nuxt.options.runtimeConfig.public || {}
    // @ts-expect-error untyped
    nuxt.options.runtimeConfig.public.skewProtection = {
      cookie: options.cookie as Required<NuxtSkewProtectionRuntimeConfig['cookie']>,
      debug: options.debug,
    } as Required<NuxtSkewProtectionRuntimeConfig>

    // Detect Nitro preset
    const nitroPreset = nuxt.options.nitro?.preset || resolveNitroPreset(nuxt.options.nitro)

    // Add TypeScript types
    addTypeTemplate({
      filename: 'types/nuxt-skew-protection.d.ts',
      getContents: () => {
        return `// Generated by nuxt-skew-protection
declare module '#app' {
  interface NuxtAppManifestMeta {
    skewProtection?: {
      versions?: Record<string, {
        timestamp: string
        expires: string
        assets: string[]
        deletedChunks?: string[]
      }>
    }
  }
}

declare module 'nuxt/app' {
  interface NuxtAppManifestMeta {
    skewProtection?: {
      versions?: Record<string, {
        timestamp: string
        expires: string
        assets: string[]
        deletedChunks?: string[]
      }>
    }
  }
}

export {}
`
      },
    }, {
      nuxt: true,
    })

    addComponent({
      name: 'SkewNotification',
      filePath: resolver.resolve(`./runtime/app/components/SkewNotification.vue`),
    })

    addPlugin({
      src: resolver.resolve('./runtime/app/plugins/0.skew-protection'),
    })

    // add useSkewProtection composable import
    addImports({
      name: 'useSkewProtection',
      from: resolver.resolve('./runtime/app/composables/useSkewProtection'),
    })

    // add alias for nuxt-skew-protection/server -> src/runtime/server
    nuxt.options.alias['nuxt-skew-protection/server'] = resolver.resolve('./runtime/server')
    if (options.storage?.driver) {
      // Mount storage for runtime access
      nuxt.options.nitro = nuxt.options.nitro || {}
      nuxt.options.nitro.storage = nuxt.options.nitro.storage || {}
      nuxt.options.nitro.storage['skew-protection'] = options.storage
    }

    // Skip production setup in dev mode
    if (!nuxt.options.dev) {
      // Detect platform at build time (reuse nitroPreset from above)
      // const nitroPreset = await resolveNitroPreset(nuxt) - already declared above
      const isCloudflareRuntime = nitroPreset?.includes('cloudflare')
      const isVercel = nitroPreset?.includes('vercel') || process.env.VERCEL_SKEW_PROTECTION_ENABLED === '1'
      if (!options.checkForUpdateStrategy) {
        options.checkForUpdateStrategy = isStaticPreset(nuxt) ? 'polling' : isCloudflareRuntime ? 'ws' : options.checkForUpdateStrategy || 'sse'
      }

      if (isVercel) {
        addServerHandler({
          handler: resolver.resolve('./runtime/server/middleware/vercel-skew'),
          middleware: true,
        })
      }

      addServerHandler({
        handler: resolver.resolve('./runtime/server/middleware/set-skew-protection-cookie'),
        middleware: true,
      })

      addPlugin({
        src: resolver.resolve('./runtime/app/plugins/sw-track-user-modules.client'),
        mode: 'client',
      })

      // allow us to use the non-transpiled version of the service worker from the module or root dir
      let swPath = resolver.resolve('./sw')
      if (!existsSync(swPath)) {
        // fallback to root dir
        swPath = resolver.resolve('../sw')
      }
      // Add service worker as public asset
      nuxt.options.nitro = nuxt.options.nitro || {}
      nuxt.options.nitro.publicAssets = nuxt.options.nitro.publicAssets || []
      nuxt.options.nitro.publicAssets.push({
        dir: swPath,
        maxAge: 0, // Service workers should not be cached
        baseURL: '/_skew',
      })

      // Add build hooks for asset versioning (skip if bundling is disabled)
      if (options.storage && options.bundlePreviousDeploymentChunks) {
        // Track build-time storage config for build operations
        // Use CLI drivers for build-time, native bindings for runtime
        nuxt.hook('nitro:build:public-assets', async (nitro) => {
          const buildId = nuxt.options.runtimeConfig.app.buildId ||= nuxt.options.buildId
          const outputDir = nitro.options.output.dir

          const assetManager = createAssetManager({
            ...options,
            driver: await resolveBuildTimeDriver(options.storage!),
          })

          // Get list of assets from build
          const assets = await assetManager.getAssetsFromBuild(outputDir)

          // Update versions manifest
          const { isExistingVersion } = await assetManager.updateVersionsManifest(buildId, assets)

          // Store assets in configured storage
          await assetManager.storeAssetsInStorage(buildId, outputDir, assets)

          // Count versions (excluding current)
          const existingVersions = await assetManager.listExistingVersions()
          const versionCount = existingVersions.filter(v => v.id !== buildId).length

          // For static/prerendered builds: restore old versioned assets into public directory
          if (versionCount > 0) {
            logger.log(`Restoring build files from the last ${versionCount} release${versionCount > 1 ? 's' : ''}...`)
          }

          await assetManager.restoreOldAssetsToPublic(buildId, outputDir, assets, isExistingVersion)

          // Augment Nuxt build metadata files with skew protection data
          await assetManager.augmentBuildMetadata(buildId, outputDir)

          // Clean up expired versions
          await assetManager.cleanupExpiredVersions()
        })
      }

      // Add Durable Objects WebSocket route for real-time updates (if enabled and on Cloudflare)
      if (options.checkForUpdateStrategy === 'ws') {
        if (!nuxt.options.nitro.experimental?.websocket) {
          logger.warn('You need to enable `experimental.websocket` in your Nitro config to use WebSockets. Falling back to polling.')
          options.checkForUpdateStrategy = 'polling'
        }
        else if (isCloudflareRuntime && nitroPreset !== 'cloudflare-durable') {
          logger.warn('Websockets are only supported in Cloudflare using `cloudflare-durable` preset. Falling back to polling.')
          options.checkForUpdateStrategy = 'polling'
        }
        else {
          addServerHandler({
            route: '/_skew/ws',
            handler: resolver.resolve(`./runtime/server/routes/_skew/ws`),
          })
          addPlugin(resolver.resolve('./runtime/app/plugins/check-updates-websocket.client'))
        }
      }
      else if (options.checkForUpdateStrategy === 'sse') {
        if (isStaticPreset(nuxt) || isCloudflareRuntime) {
          logger.warn('SSE not supported for static sites or Cloudflare Workers. Falling back to polling.')
          options.checkForUpdateStrategy = 'polling'
        }
        else if (isCloudflareRuntime) {
          logger.warn('SSE not supported on Cloudflare Workers (no persistent connections). Falling back to polling.')
          options.checkForUpdateStrategy = 'polling'
        }
        else {
          addServerHandler({
            route: '/_skew/sse',
            handler: resolver.resolve('./runtime/server/routes/_skew/sse'),
          })
          addPlugin({
            src: resolver.resolve('./runtime/app/plugins/check-updates-sse.client'),
            mode: 'client',
          })
        }
      }
    }
  },
})
