import type { NuxtSkewProtectionRuntimeConfig } from '~/src/runtime/types'
import { existsSync } from 'node:fs'
import {
  addComponent,
  addImports,
  addPlugin,
  addServerHandler,
  addTypeTemplate,
  createResolver,
  defineNuxtModule,
} from '@nuxt/kit'
import { isStaticPreset, resolveNitroPreset } from './kit'
import { logger } from './logger'
import { createAssetManager } from './utils/version-manager'

export interface ModuleOptions {
  /**
   * Storage configuration for versioned assets
   */
  storage?: (Record<string, any> & {
    driver: string
  })
  /**
   * How long to retain old versions (in days)
   * @default 30
   */
  retentionDays?: number
  /**
   * Maximum number of versions to retain
   * @default 10
   */
  maxNumberOfVersions?: number
  /**
   * Strategy for checking for version updates
   * - 'polling': Nuxt's native polling of builds/latest.json (default)
   * - 'sse': Use Server-Sent Events for real-time updates (requires sse: true)
   * - 'ws': Use WebSocket via Cloudflare Durable Objects (requires durableObjects: true)
   * @default Static: 'polling', Node: 'sse', Cloudflare: 'ws'
   */
  checkForUpdateStrategy: 'polling' | 'sse' | 'ws'
  /**
   * Cookie name for storing deployment version
   * @default '__nkpv'
   */
  cookieName?: string
  /**
   * Cookie configuration
   */
  cookie?: {
    /**
     * Cookie path
     * @default '/'
     */
    path?: string
    /**
     * Cookie sameSite setting
     * @default 'strict'
     */
    sameSite?: 'strict' | 'lax' | 'none' | boolean
    /**
     * Cookie max age in seconds
     * @default 5184000 (60 days)
     */
    maxAge?: number
  }
  /**
   * Enable or disable the module
   * @default true
   */
  enabled: boolean
  /**
   * Enable debug logging
   * @default false
   */
  debug?: boolean
}

export interface ModulePublicRuntimeConfig {
  skewProtection: NuxtSkewProtectionRuntimeConfig
}

export default defineNuxtModule<ModuleOptions>({
  meta: {
    name: 'nuxt-skew-protection',
    compatibility: {
      nuxt: '>=4.0.0',
    },
    configKey: 'skewProtection',
  },
  defaults: {
    retentionDays: 30,
    maxNumberOfVersions: 10,
    cookieName: '__nkpv',
    cookie: {
      path: '/',
      sameSite: 'strict' as const,
      maxAge: 60 * 60 * 24 * 60, // 60 days
    },
    debug: false,
  },
  async setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)
    logger.level = (options.debug || nuxt.options.debug) ? 4 : 3
    if (options.enabled === false) {
      logger.debug('The module is disabled, skipping setup.')
      return
    }
    // Check for CDN URL configuration - incompatible with this module
    if (nuxt.options.app.cdnURL || process.env.NUXT_APP_CDN_URL) {
      throw new Error(
        '[skew-protection] This module is incompatible with cdnURL configuration.\n'
        + 'The module requires serving versioned assets from the origin server,\n'
        + 'which conflicts with CDN-based asset delivery where assets are served from a different domain.',
      )
    }

    // Add TypeScript types
    addTypeTemplate({
      filename: 'types/nuxt-skew-protection.d.ts',
      getContents: () => {
        return `// Generated by nuxt-skew-protection
declare module '#app' {
  interface NuxtAppManifestMeta {
    skewProtection?: {
      versions?: Record<string, {
        timestamp: string
        expires: string
        assets: string[]
        deletedChunks?: string[]
      }>
    }
  }
}

declare module 'nuxt/app' {
  interface NuxtAppManifestMeta {
    skewProtection?: {
      versions?: Record<string, {
        timestamp: string
        expires: string
        assets: string[]
        deletedChunks?: string[]
      }>
    }
  }
}

export {}
`
      },
    }, {
      nuxt: true,
    })

    addComponent({
      name: 'SkewNotification',
      filePath: resolver.resolve(`./runtime/app/components/SkewNotification.vue`),
    })

    addPlugin({
      src: resolver.resolve('./runtime/app/plugins/0.skew-protection.ts'),
    })

    // add useSkewProtection composable import
    addImports({
      name: 'useSkewProtection',
      from: resolver.resolve('./runtime/app/composables/useSkewProtection'),
    })

    // cookie as well
    addImports({
      name: 'useSkewProtectionCookie',
      from: resolver.resolve('./runtime/app/composables/useSkewProtectionCookie'),
    })

    // add alias for nuxt-skew-protection/server -> src/runtime/server
    nuxt.options.alias['nuxt-skew-protection/server'] = resolver.resolve('./runtime/server')

    // don't register other plugins in dev mode
    if (nuxt.options.dev) {
      return
    }

    // Detect platform at build time
    const nitroPreset = resolveNitroPreset()
    const isCloudflare = nitroPreset.includes('cloudflare')
    const isVercel = nitroPreset.includes('vercel') || process.env.VERCEL_SKEW_PROTECTION_ENABLED === '1'
    if (!options.checkForUpdateStrategy) {
      options.checkForUpdateStrategy = isStaticPreset(nuxt) ? 'polling' : isCloudflare ? 'ws' : options.checkForUpdateStrategy || 'sse'
    }
    // only node needs specific storage handling vercdel & cloudflare have their own mechanisms
    if (!options.storage) {
      options.storage = {
        driver: 'fs',
        base: 'node_modules/.cache/nuxt/skew-protection',
      }
      // log warning that it may not be suitable for production
      logger.warn(
        '[skew-protection] No storage driver configured, defaulting to local filesystem storage.\n'
        + 'This may not be suitable for production environments.\n'
        + 'Please configure a persistent storage solution (e.g., S3, Redis) in the module options.',
      )
    }
    // Mount storage for runtime access
    nuxt.options.nitro.storage = nuxt.options.nitro.storage || {}
    nuxt.options.nitro.storage['skew-protection'] = options.storage

    if (isVercel) {
      addServerHandler({
        handler: './runtime/server/middleware/vercel-skew.ts',
        middleware: true,
      })
    }

    addServerHandler({
      handler: resolver.resolve('./runtime/server/middleware/set-skew-protection-cookie.ts'),
      middleware: true,
    })

    addPlugin({
      src: resolver.resolve('./runtime/app/plugins/sw-track-user-modules.client.ts'),
      mode: 'client',
    })

    // allow us to use the non-transpiled version of the service worker from the module or root dir
    let swPath = resolver.resolve('./sw')
    if (!existsSync(swPath)) {
      // fallback to root dir
      swPath = resolver.resolve('../sw')
    }
    // Add service worker as public asset
    nuxt.options.nitro.publicAssets = nuxt.options.nitro.publicAssets || []
    nuxt.options.nitro.publicAssets.push({
      dir: swPath,
      maxAge: 0, // Service workers should not be cached
    })

    // Add build hooks for asset versioning
    nuxt.hook('nitro:build:public-assets', async (nitro) => {
      const buildId = nuxt.options.runtimeConfig.app.buildId ||= nuxt.options.buildId
      const outputDir = nitro.options.output.dir

      const assetManager = createAssetManager(options)

      // Get list of assets from build
      const assets = await assetManager.getAssetsFromBuild(outputDir)

      // Update versions manifest
      const { isExistingVersion } = await assetManager.updateVersionsManifest(buildId, assets)

      // Store assets in configured storage
      await assetManager.storeAssetsInStorage(buildId, outputDir, assets)

      // Count versions (excluding current)
      const existingVersions = await assetManager.listExistingVersions()
      const versionCount = existingVersions.filter(v => v.id !== buildId).length

      // For static/prerendered builds: restore old versioned assets into public directory
      if (versionCount > 0) {
        logger.log(`Restoring build files from the last ${versionCount} release${versionCount > 1 ? 's' : ''}...`)
      }

      await assetManager.restoreOldAssetsToPublic(buildId, outputDir, assets, isExistingVersion)

      // Augment Nuxt build metadata files with skew protection data
      await assetManager.augmentBuildMetadata(buildId, outputDir)

      // Clean up expired versions
      await assetManager.cleanupExpiredVersions()
    })

    // Add Durable Objects WebSocket route for real-time updates (if enabled and on Cloudflare)
    if (options.checkForUpdateStrategy === 'ws') {
      if (!nitro.options.experimental.websockets) {
        logger.warn('You need to enable `experimental.websockets` in your Nitro config to use WebSockets. Falling back to polling.')
        options.checkForUpdateStrategy = 'polling'
      }
      else if (isCloudflare && nitroPreset !== 'cloudflare-durable') {
        logger.warn('Websockets are only supported in Cloudate using `cloudflare-durable` preset. Falling back to polling.')
        options.checkForUpdateStrategy = 'polling'
      }
      else {
        addServerHandler({
          route: '/_skew/ws',
          handler: resolver.resolve(`./runtime/server/routes/_skew/ws.ts`),
        })
        addPlugin(resolver.resolve('./runtime/app/plugins/check-updates-websocket.client.ts'))
      }
    }
    else if (options.checkForUpdateStrategy === 'sse') {
      if (isStaticPreset(nuxt) || isCloudflare) {
        logger.warn('SSE not supported for static sites. Falling back to polling.')
        options.checkForUpdateStrategy = 'polling'
      }
      else if (isCloudflare) {
        logger.warn('SSE not supported on Cloudflare Workers (no persistent connections). Falling back to polling.')
        options.checkForUpdateStrategy = 'polling'
      }
      else {
        addServerHandler({
          route: '/_skew/sse',
          handler: resolver.resolve('./runtime/server/routes/_skew/sse.ts'),
        })
        addPlugin({
          src: resolver.resolve('./runtime/app/plugins/check-updates-sse.client.ts'),
          mode: 'client',
        })
      }
    }
    if (options.checkForUpdateStrategy === 'polling') {
      // no action needed?
      // TODO remove this
      nuxt.options.experimental.checkOutdatedBuildInterval = 20 // 20 seconds
    }

    // Add runtime config for client access to module options
    nuxt.options.runtimeConfig.public = nuxt.options.runtimeConfig.public || {}
    nuxt.options.runtimeConfig.public.skewProtection = {
      cookieName: options.cookieName,
      cookie: options.cookie,
      debug: options.debug,
    }
  },
})
