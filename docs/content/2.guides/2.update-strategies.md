---
title: Update Detection Strategies
description: Choose the best update detection strategy for your platform.
---

Nuxt Skew Protection supports three strategies for detecting new deployments. Each has trade-offs in terms of real-time responsiveness, platform compatibility, and resource usage.

## Quick Comparison

| Strategy | Real-time | Platforms | Server Load | Client Connections |
|----------|-----------|-----------|-------------|-------------------|
| **Polling** | ❌ Delayed | ✅ All | ✅ Minimal | ✅ None |
| **SSE** | ✅ Instant | ⚠️ Node.js/Bun/Deno | ⚠️ Moderate | ⚠️ Persistent |
| **WebSocket** | ✅ Instant | ⚠️ Cloudflare Durable | ⚠️ Moderate | ⚠️ Persistent |

## Polling Strategy

The default strategy that works on **all platforms**.

### How it Works

Uses Nuxt's built-in `experimental.checkOutdatedBuildInterval` to periodically fetch `builds/latest.json`:

```http
GET /builds/latest.json

{
  "id": "abc123",
  "timestamp": 1234567890
}
```

If `id` changes, Nuxt fires the `app:manifest:update` hook, triggering skew protection checks.

### Configuration

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  skewProtection: {
    checkForUpdateStrategy: 'polling'
  },

  experimental: {
    // Check every hour (default: 1 hour)
    checkOutdatedBuildInterval: 3600000 // milliseconds
  }
})
```

### Pros & Cons

**Pros:**

- ✅ Works everywhere (Node.js, Cloudflare, Vercel, static sites)
- ✅ No persistent connections
- ✅ Minimal server resources
- ✅ No additional configuration needed

**Cons:**

- ❌ Delayed detection (depends on polling interval)
- ❌ Users may not know about updates until next poll
- ⚠️ Network requests even when no updates

### Best For

- Static sites (Netlify, GitHub Pages, etc.)
- Platforms where SSE/WebSocket aren't supported
- Low-traffic sites where instant updates aren't critical
- Serverless platforms with connection limits

## SSE Strategy

Real-time updates using **Server-Sent Events**.

### How it Works

Client opens a persistent connection to the server:

```ts
// Client connects
const eventSource = new EventSource('/_skew/sse')

eventSource.onmessage = (event) => {
  const { buildId } = JSON.parse(event.data)
  // Instant update detection!
}
```

Server pushes updates when deployments occur:

```text
event: message
data: {"type":"version","buildId":"abc123"}

event: message
data: {"type":"keepalive"}
```

### Configuration

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  skewProtection: {
    checkForUpdateStrategy: 'sse'
  }
})
```

SSE is the **default strategy** on Node.js/Bun/Deno platforms.

### Pros & Cons

**Pros:**

- ✅ Instant updates when deployments occur
- ✅ Efficient (server pushes only when needed)
- ✅ Built-in reconnection logic
- ✅ Simple protocol (text-based)

**Cons:**

- ❌ Not supported on Cloudflare Workers (use WebSocket instead)
- ⚠️ One persistent connection per client
- ⚠️ Some proxies/firewalls may block SSE
- ⚠️ Server must handle many concurrent connections

### Best For

- Node.js, Bun, Deno deployments
- Apps where instant update detection is important
- Platforms supporting long-lived HTTP connections

### Platform Compatibility

| Platform | Supported | Notes |
|----------|-----------|-------|
| Node.js | ✅ Yes | Default |
| Bun | ✅ Yes | Default |
| Deno | ✅ Yes | Default |
| Vercel | ✅ Yes | Default |
| Cloudflare Workers | ❌ No | Use WebSocket |
| Netlify | ✅ Yes | |
| Static | ❌ No | Use Polling |

## WebSocket Strategy

Real-time updates using **WebSockets**, designed for Cloudflare Durable Objects.

### How it Works

Client opens a bidirectional WebSocket connection:

```ts
// Client connects
const ws = new WebSocket('/_skew/ws')

ws.onmessage = (event) => {
  const { type, buildId } = JSON.parse(event.data)

  if (type === 'version') {
    // New version detected!
  }
}

// Heartbeat to keep connection alive
setInterval(() => {
  ws.send(JSON.stringify({ type: 'ping' }))
}, 30000)
```

Server responds with pongs and version updates:

```text
{ "type": "connected", "buildId": "abc123" }
{ "type": "pong" }
{ "type": "version", "buildId": "def456" }
```

### Configuration

Requires Cloudflare Durable Objects preset:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  nitro: {
    preset: 'cloudflare-durable',
    experimental: {
      websockets: true
    }
  },

  skewProtection: {
    checkForUpdateStrategy: 'ws'
  }
})
```

### Pros & Cons

**Pros:**

- ✅ Real-time, bidirectional communication
- ✅ Works on Cloudflare Durable Objects
- ✅ Instant update detection
- ✅ Heartbeat keeps connection alive

**Cons:**

- ❌ Requires Cloudflare Durable Objects (not free tier)
- ❌ More complex than SSE
- ⚠️ One persistent connection per client
- ⚠️ Requires `experimental.websockets` flag

### Best For

- Cloudflare Workers/Pages with Durable Objects
- Apps deployed on Cloudflare infrastructure
- When you need real-time updates on Cloudflare

### Setup for Cloudflare

1. **Enable Durable Objects:**

   ```toml [wrangler.toml]
   [[durable_objects.bindings]]
   name = "SKEW_PROTECTION"
   class_name = "SkewProtection"
   script_name = "nuxt-app"
   ```

2. **Configure Nitro:**

   ```ts [nuxt.config.ts]
   export default defineNuxtConfig({
     nitro: {
       preset: 'cloudflare-durable',
       experimental: {
         websockets: true
       }
     }
   })
   ```

3. **Enable WebSocket strategy:**

   ```ts [nuxt.config.ts]
   export default defineNuxtConfig({
     skewProtection: {
       checkForUpdateStrategy: 'ws'
     }
   })
   ```

## Auto-Detection

The module automatically selects the best strategy based on your build environment:

```ts
// Module's strategy detection logic
const strategy
  = isStatic
    ? 'polling'
    : isCloudflare
      ? 'ws'
      : 'sse' // Node.js, Bun, Deno
```

You can override this with explicit configuration:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  skewProtection: {
    // Force a specific strategy
    checkForUpdateStrategy: 'sse' // or 'polling' or 'ws'
  }
})
```

## Hybrid Approach

You can use different strategies for different environments:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  skewProtection: {
    checkForUpdateStrategy: process.env.NODE_ENV === 'production'
      ? 'sse' // Real-time in production
      : 'polling' // Polling in dev
  }
})
```

## Testing Your Strategy

### Verify SSE Connection

1. Open browser DevTools → Network tab
2. Filter by "sse" or "EventStream"
3. Should see persistent connection to `/_skew/sse`

### Verify WebSocket Connection

1. Open browser DevTools → Network tab
2. Filter by "WS"
3. Should see WebSocket connection to `/_skew/ws`
4. Check messages for `type: "connected"`

### Verify Polling

1. Open browser DevTools → Network tab
2. Filter by "latest.json"
3. Should see periodic requests to `/builds/latest.json`

### Trigger Manual Update Check

```js
// Browser console
const { checkForUpdates } = useSkewProtection()
await checkForUpdates()
```

## Recommendations

### Production Apps

- **Node.js/Vercel:** Use SSE (default)
- **Cloudflare:** Use WebSocket
- **Static:** Use Polling

### Development

- Use Polling to avoid persistent connections
- Or disable update checks entirely:

  ```ts
  skewProtection: {
    enabled: process.env.NODE_ENV === 'production'
  }
  ```

### High-Traffic Sites

- Consider Polling to reduce server connection load
- Or implement rate limiting on SSE/WebSocket endpoints

### Low-Traffic Sites

- SSE/WebSocket are fine and provide best UX
- Instant updates with minimal overhead

## Next Steps

- [Storage Configuration](/docs/skew-protection/guides/storage-configuration) - Configure persistent storage
- [Platform Guides](/docs/skew-protection/guides/platforms) - Platform-specific setup
- [How it Works](/docs/skew-protection/guides/how-it-works) - Understand the architecture
